# 🚀 SPARC-Omega Vibe Coding: Ontology + Perplexity + GitHub + Hyperbrowser!

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Roo Code Compatible](https://img.shields.io/badge/Roo%20Code-Compatible-brightgreen)](https://roo.ai)
[![Perplexity API](https://img.shields.io/badge/Perplexity-API-blue)](https://perplexity.ai)
[![GitHub Tools](https://img.shields.io/badge/GitHub-Tools-purple)](https://github.com)
[![Hyperbrowser Tools](https://img.shields.io/badge/Hyperbrowser-Tools-cyan)](https://github.com/hyperbrowserai/mcpglobal)
[![cline MCP Installer](https://img.shields.io/badge/cline-MCP%20Installer-orange)](https://cline.tools)

## 🎧 What is This? (The SPARC-Omega Vibe Explained)

Forget coding blind. This is **SPARC-Omega Vibe Coding** – a next-level framework for AI-driven development. We fuse Roo Code's multi-agent system with Perplexity's research, GitHub's repository management, and **Hyperbrowser's advanced web scraping and browser automation**, all guided by an **integrated Ontology** and orchestrated by the **SPARC-Omega methodology**.

Here's the flow: You spark an idea. SPARC-Omega kicks in, using Ontology insights to proactively anticipate challenges. It delegates tasks to a specialized crew of AI agents:

-   🌟 **SPARC-Omega Orchestrator**: Runs the show, integrating Ontology knowledge and coordinating MCP tools.
-   🔍 **Research Specialists**: Leverage Perplexity for cutting-edge info and Hyperbrowser (`scrape`, `crawl`, `extract`) for deep web data gathering.
-   🐙 **Git Managers**: Handle GitHub repos, branches, commits like pros.
-   🧠 **Coders & Architects**: Build modular, Ontology-informed solutions, researching examples with Perplexity/Hyperbrowser.
-   🧪 **Testers**: Implement TDD, using Ontology to target tests and **Hyperbrowser Agents (`browser_use_agent`, `openai_...`, `claude_...`) for automated UI/E2E testing**.
-   🛡️ **Security Reviewers**: Audit code, focusing on Ontology-flagged vulnerabilities.
-   🚀 **DevOps**: Automate infrastructure and deployments, potentially using **Hyperbrowser Agents for complex console interactions** when APIs fall short.
-   ...and many more (Docs, Debugging, Integration, Optimization, Monitoring) – each enhanced with Ontology awareness and specific MCP tool access.

This isn't just autocomplete; it's **proactive, Ontology-guided, research-backed, automated full-lifecycle development** with agents that can *see, interact with, and extract data from the web* like never before.

## 🔄 NEW: SPARC-Omega Methodology & Ontology Integration

We've evolved beyond simple prediction. The system now operates on the **SPARC-Omega methodology**, deeply integrated with a structured **Ontology**:

### 🏛️ Ontology-Guided Foresight

Before coding, agents consult an **Ontology** (a structured knowledge base about technologies, problems, solutions, patterns, vulnerabilities, etc.):

-   **:Problem Anticipation**: Identify likely issues (`:SecurityVulnerability`, `:CompatibilityIssue`, `:PerformanceIssue`) based on the chosen tech stack *before* they arise.
-   **:Solution Guidance**: Leverage known best practices and `:ArchitecturalPattern`s from the Ontology.
-   **Validation**: Check design choices and integrations against Ontology constraints (`:PlatformIncompatibility`, `:APIBreakingChange`).

### ✨ SPARC-Omega Workflow

The enhanced SPARC flow ensures robust, proactive development:

1.  **Specification**: Clarify goals, *using Ontology concepts* to frame requirements and risks. Leverage Perplexity/Hyperbrowser for research.
2.  **Pseudocode**: Request high-level logic with TDD anchors, *informed by Ontology checks*.
3.  **Architecture**: Design extensible systems, *validated against Ontology patterns*. Use Perplexity/Hyperbrowser for architectural research.
4.  **Refinement**: Employ TDD (including **Hyperbrowser-powered UI tests**), Ontology-guided debugging, security reviews, and optimization.
5.  **Completion**: Integrate (*verifying against Ontology*), document (*referencing Ontology*), monitor (*potentially using Hyperbrowser for synthetic checks*), and deploy.

This proactive, knowledge-driven approach dramatically improves code quality, security, and efficiency from the start.

## ✨ Why It's a Game Changer

Traditional AI coding tools operate in a vacuum. SPARC-Omega rewrites the rules:

-   🧠 **Proactive Problem Solving**: Ontology integration anticipates issues before they're coded.
-   🌐 **Full Web Interaction**: Hyperbrowser enables agents to scrape data, crawl sites, extract structured info, and **autonomously drive web browsers** for testing, research, or automation.
-   🐙 **Automated GitHub Workflow**: Seamlessly manage your entire GitHub presence programmatically.
-   💡 **Real-Time Research Power**: Perplexity keeps agents informed with the latest documentation, APIs, and best practices.
-   ✅ **Evidence-Based Quality**: Decisions are rooted in structured Ontology knowledge and real-time research.
-   💻 **True Full Lifecycle Coverage**: From Ontology-guided design and Hyperbrowser-driven testing to automated deployment and monitoring.
-   💸 **Cost-Effective Power**: Leverage potentially free models (like Gemini Flash/Pro via API when available) with efficient Perplexity/Hyperbrowser usage. GitHub MCP tools remain free.

## 🛠️ The Core Components

This framework integrates state-of-the-art AI capabilities:

### 1. The SPARC-Omega Multi-Agent Army (.roomodes) 🤖

A squad of specialized AI personas defined in the `.roomodes` file (included), each aware of the Ontology and their assigned MCP tools:

-   🌟 **SPARC-Omega Orchestrator**: The Ontology-aware maestro.
-   📋 **Spec Writer (Omega)**: Uses Ontology + Perplexity/Hyperbrowser (scrape, crawl, extract, *maybe* agents) for deep requirements gathering.
-   🏗️ **Architect (Omega)**: Designs systems validated against Ontology + Perplexity/Hyperbrowser research.
-   🧠 **Coder (Omega)**: Writes Ontology-informed code using GitHub + Perplexity/Hyperbrowser (scrape, extract).
-   🧪 **Tester (TDD, Omega)**: Writes Ontology-guided tests, executes **UI/E2E tests via Hyperbrowser Agents**.
-   🪲 **Debugger (Omega)**: Uses Ontology + Perplexity/Hyperbrowser (scrape, extract, *maybe* agents for reproduction).
-   🛡️ **Security Reviewer (Omega)**: Focuses audits using Ontology + Perplexity/GitHub Search/Hyperbrowser (scrape, crawl).
-   📚 **Docs Writer (Omega)**: References Ontology + uses GitHub/Hyperbrowser (scrape, extract).
-   🔗 **Integrator (Omega)**: Verifies against Ontology + uses GitHub, *maybe runs E2E tests via Hyperbrowser Agents*.
-   🚀 **DevOps (Omega)**: Uses Ontology + GitHub/Perplexity/Hyperbrowser (scrape, *maybe agents for console automation*).
-   📈 **Monitor (Omega)**: Guided by Ontology, *maybe sets up synthetic monitoring via Hyperbrowser Agents*.
-   🧹 **Optimizer (Omega)**: Guided by Ontology + uses GitHub/Perplexity/Hyperbrowser (scrape, extract).
-   ❓ **Ask (Omega Guide)**: Your guide to the SPARC-Omega system!

(Check the included `.roomodes` file for full details and instructions!)

### 2. Ontology-Guided Intelligence 🏛️

A structured knowledge layer (defined conceptually within the modes' instructions) that informs agent decisions about potential problems, solutions, patterns, and compatibilities, enabling proactive development.

### 3. Perplexity Research Power 💡

Integrated via MCP for real-time knowledge:

-   `search`, `get_documentation`, `find_apis`, `check_deprecated_code`, `chat_perplexity`.

### 4. GitHub Sidekick (MCP Tools) 🐙

Full programmatic control over your repositories:

-   Repo Ops (`create_repository`, `fork_repository`).
-   File Ops (`create_or_update_file`, `push_files`, `get_file_contents`).
-   Branching/Commits (`create_branch`, `list_commits`).
-   Issues/PRs (`create_issue`, `create_pull_request`).
-   Discovery (`search_code`, `search_repositories`).

### 5. Hyperbrowser Superpowers (MCP Tools) 🌐

Unlocks advanced web interaction via MCP (from `mcpglobal`):

-   **Data Extraction**:
    -   `scrape_webpage`: Get content from a single URL.
    -   `crawl_webpages`: Explore and collect data from multiple linked pages.
    -   `extract_structured_data`: Pull specific information using prompts/schemas.
-   **Browser Automation Agents**:
    -   `browser_use_agent`: Fast, cost-effective agent for *explicit, step-by-step* tasks.
    -   `openai_computer_use_agent`: General-purpose agent using OpenAI for standard web interactions.
    -   `claude_computer_use_agent`: Advanced agent using Claude for complex, nuanced tasks requiring sophisticated reasoning.
-   **Web Search**:
    -   `search_with_bing`: Perform web searches directly.

## 🎬 See It In Action (Usage Examples)

### Example 1: Ontology-Guided Feature Planning with Web Research

**User**: "Let's spec out a feature to integrate Stripe payments into our Next.js app. Use Supabase for user data."

**🌟 SPARC-Omega Orchestrator**: "Vibing! 🚀 Let's plan this with foresight. Assigning to `spec-pseudocode-omega`. Task: Define requirements for Stripe integration in Next.js/Supabase context. *Consult Ontology for known `:CompatibilityIssue`s or `:SecurityVulnerability` patterns* related to Stripe/Supabase auth. Use Perplexity (`search`, `get_documentation`) for latest Stripe API best practices and Hyperbrowser (`crawl_webpages`) on `stripe.com/docs` to gather detailed flow examples. Create modular pseudocode with TDD anchors. `attempt_completion`."

**(Later) 📋 Spec Writer (Omega)**: "Ontology check flagged potential issues with handling webhook secrets securely (`:SecurityVulnerability`) and ensuring transaction atomicity with Supabase (`:Problem`). Researched via Perplexity & crawled Stripe docs using Hyperbrowser. Pseudocode includes secure webhook handling via env vars and database transaction logic. Ready! `attempt_completion`."

### Example 2: Automated UI Testing with Hyperbrowser Agent

**User**: "Okay, the login flow is coded. Let's add an E2E test to ensure users can log in via email."

**🌟 SPARC-Omega Orchestrator**: "Solid! 🧪 Assigning to `tdd-omega`. Task: Create and run an E2E test for the email login flow. *Consult Ontology for common login `:Problem` types* to cover edge cases (e.g., invalid password, non-existent user). Use Hyperbrowser's `openai_computer_use_agent` to execute the test steps against the staging URL [provide URL]. Steps: 1. Navigate to login page. 2. Find email input, enter 'test@example.com'. 3. Find password input, enter 'password123'. 4. Click login button. 5. Verify successful redirect to dashboard URL or presence of 'Welcome' text. Report results. `attempt_completion`."

**(Later) 🧪 Tester (TDD, Omega)**: "Ontology suggested testing case-insensitivity for email, added that step. Defined task for `openai_computer_use_agent`. Executing... Agent successfully navigated, entered credentials, clicked login, and verified dashboard access. Test passed! `attempt_completion`."

## 🔧 Get Started (Join the Vibe!)

Ready to code with foresight and automation?

### Prerequisites
-   VS Code with the Roo Code extension.
-   Perplexity API key.
-   GitHub Personal Access Token (scopes: repo, workflow, issues, etc.).
-   **Hyperbrowser API Key/Setup**: Access to Hyperbrowser tools (see [Hyperbrowser MCP Global Repo](https://github.com/hyperbrowserai/mcpglobal)).

### Easiest MCP Setup: Use cline!
1.  Install [cline](https://cline.tools).
2.  In cline, search for and install the MCP providers: "Perplexity AI", "GitHub", and "**Hyperbrowser**".
3.  Follow cline's prompts (it uses AI to set up the servers, likely asking for your API keys/tokens).
4.  Copy the MCP settings (URLs, headers/tokens) cline provides for each service.

### Configure Roo Code
1.  Open Roo Code settings in VS Code (Ctrl+Shift+P -> "Roo Code: Open Settings").
2.  Paste the Perplexity, GitHub, and **Hyperbrowser** MCP details copied from cline into the corresponding "Model Context Protocol (MCP) Settings" sections.

### Install the SPARC-Omega RooModes
1.  Copy the `.roomodes` file from this repository into the root directory of your project (or a parent directory).
2.  Roo Code will automatically detect and load the modes. (You can also save modes globally via Roo Code's UI/CLI if preferred).
    *   *Note*: The core logic and instructions, including Ontology guidance and tool usage, are now embedded within each mode definition in this `.roomodes` file.

### Start Vibing!
1.  Open a Roo Code chat in VS Code.
2.  Select an Omega mode (e.g., `🌟 SPARC-Omega Orchestrator`) from the mode selector.
3.  Give it a high-level objective and watch the Ontology-guided, tool-wielding AI agents collaborate!

## 📜 License
Licensed under the MIT License—see the `LICENSE` file for details.

## 🔗 Related Resources
-   [Roo Code Docs](https://roo.ai/docs)
-   [Perplexity API Docs](https://perplexity.ai/api)
-   [GitHub API Docs](https://docs.github.com/en/rest)
-   [Hyperbrowser MCP Global Repo](https://github.com/hyperbrowserai/mcpglobal) (For Hyperbrowser tool details)
-   [MCP Standard](https://mcp.ai) (Underlying protocol)
-   [cline Setup](https://cline.tools) (Easiest MCP Server Setup)

---

Built with ❤️ by SPARC-Omega vibe coders. Let's automate the future, proactively!
