# üöÄ Zero-Code SPARC AI: Your Vision, Built by AI (Powered by Roo Code & Enhanced Tooling)

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Roo Code Compatible](https://img.shields.io/badge/Roo%20Code-Compatible-brightgreen)](https://roo.ai)
[![Blueprint Driven](https://img.shields.io/badge/Input-Uber%20Prompt%20SPARC-blue)](./Uber%20Prompt%20SPARC.pdf)
[![SPARC Methodology](https://img.shields.io/badge/Methodology-SPARC%20(Reuven%20Cohen)-orange)](.)
[![AI Models (e.g., Claude 3.x)](https://img.shields.io/badge/AI%20Models-Claude%203.x/GPT--4-orange)](.)
[![MCP Enabled Agents](https://img.shields.io/badge/Agents-MCP%20Enabled-purple)](.)
[![Video Demo Included](https://img.shields.io/badge/Demo-Video%20Context-informational)](.)

**Based on the powerful SPARC methodology and foundational agent definitions pioneered by Reuven Cohen.**

---

## üåå What is This? (From Your Vision to Working Software, Without Code)

Welcome! This repository demonstrates and provides the tools for a groundbreaking approach to software creation. It enables **anyone with an idea (we call you the Visionary!)** to describe their desired program in plain English using the **`Uber Prompt SPARC.pdf`**, and then watch as a sophisticated team of AI agents, orchestrated by **SPARC** (and powered by the Roo Code VS Code extension), automatically builds it.

**The Problem:** Bringing a software idea to life often requires deep technical knowledge, creating a barrier for entrepreneurs, subject-matter experts, and creative thinkers.

**Our Solution:** We bridge this gap! This repository offers:

1. **A Structured Input:** The `Uber Prompt SPARC.pdf` translates your vision into a format AI can understand, without you writing a single line of code.
2. **An Intelligent AI Workforce:** The `.roomodes` file defines a versatile team of specialized AI agents (Architects, Coders, Testers, Researchers, Database Admins, Web Crawlers, etc.), ready to execute your blueprint using the robust **SPARC methodology**.
3. **Enhanced Tooling & Research:** This configuration integrates powerful **Deep Research** (using Perplexity) and **Web Crawling** (using Firecrawl) agents directly into the SPARC workflow. It also includes pre-researched documentation (like the Spark Report, Workflow, and "Uber Prompt" demonstrated in the included video context) to kickstart AI understanding and prompt generation for common development tasks.
4. **Streamlined SPARC Implementation:** This project bundles necessary SPARC modes (like Deep Research and Firecrawler) and provides clear documentation (`SPARC Development Workflow.pdf`) on how to apply the methodology effectively within the Roo Code environment.

**The Goal:** To empower *you*, the Visionary, to transform your ideas into functional software by leveraging cutting-edge AI collaboration, making the powerful SPARC framework more accessible and even more potent through structured input and integrated research.

*The process and tools demonstrated here were showcased in the accompanying video.*

<div align="center">
  <a href="https://youtu.be/q3CdigR2IvU">
    <img src="https://img.youtube.com/vi/q3CdigR2IvU/maxresdefault.jpg" alt="Watch the Demo Video" style="width:100%;max-width:800px;">
  </a>
  <br>
  <b>üé• Click to watch the Zero-Code SPARC AI Demo Video</b>
</div>

---

## ‚ú® Key Pillars & How It Works

This system rests on several key pillars:

1. **Uber Prompt SPARC:** Your starting point. A detailed questionnaire (`.pdf` included) designed for non-technical users to articulate their project goals, target audience, desired features, essential rules, and success criteria in plain English. *This becomes the primary input for the AI team.*
2. **SPARC Methodology (by Reuven Cohen):** The core operational framework ‚Äì **S**pecification, **P**seudocode, **A**rchitecture, **R**efinement, **C**ompletion. This structured approach ensures a logical flow from idea to deployment, managed by the Orchestrator.
3. **SPARC Orchestrator (‚ö°Ô∏è Mode):** The AI project manager. It interprets the Blueprint, consults the integrated research documents, breaks down the project using the SPARC workflow (`SPARC Development Workflow.pdf`), and delegates tasks to specialized AI agents.
4. **Specialized AI Agent Team (Roomodes):** Defined in `.roomodes`, this is your AI development team. Each agent (mode) has a specific role, instructions, and access to tools (like coding, testing, security scanning, database management, research via MCP). We've included and integrated essential agents like Deep Research, Fire Crawler, and Supabase Admin.
5. **Integrated Deep Research & Context:** The `üîç Deep Research` and `üî• Fire Crawler` agents proactively gather external knowledge. Furthermore, the included documents (SPARC Report, SPARC Development Workflow, Uber Prompt SPARC from the video demo) provide immediate, rich context to the AI, significantly enhancing its ability to plan and generate relevant prompts and code, especially for AI-assisted development tasks themselves.
6. **Outcome-Driven Development:** The focus is squarely on achieving the goals and `Success Criteria` you define in the Blueprint. The AI figures out the technical "how" based on your desired "what" and "why".

---

## üîÑ Conceptual Workflow: From Your Brain to AI-Built App

```
    [You (Visionary)] -- Fills out --> (Uber Prompt SPARC PDF);
    Provides content to --> {‚ö°Ô∏è SPARC Orchestrator (in Roo Code)};
    Uses --> [üìÑ SPARC Development Workflow];
    Consults --> [üìö Enhanced Docs (SPARC Report, Uber Prompt, etc.)];
    Delegates Task 1 --> (üîç Deep Research);
    Gathers Info --> ;
    Delegates Task 2 --> (üìã Specification Writer);
    Creates Specs --> ;
    Delegates Task 3 --> (üèóÔ∏è Architect);
    Designs System --> ;
    Delegates Tasks (Iterative) --> (üß† Code / üß™ TDD / üîê Supabase Admin / etc.);
    Builds & Tests --> ;
    Delegates Final Tasks --> (üîó Integrator / üõ°Ô∏è Security / üìö Docs / üöÄ DevOps);
    Finalizes & Deploys --> {‚úÖ Working Program!};
    Matches --> (üéØ Success Criteria from Blueprint);
```

---

## üõ†Ô∏è The Core Components in This Repository

* **üìÑ Uber Prompt SPARC.pdf:** The essential questionnaire for capturing your vision. This is your primary interaction point. 
  ‚û°Ô∏è [Download/View Blueprint](./Uber%20Prompt%20SPARC.pdf)
  
* **ü§ñ .roomodes:** The JSON configuration defining the specialized AI agents for Roo Code. Includes the SPARC orchestrator and critical modes like Deep Research, Fire Crawler, Supabase Admin, and more, integrating the concepts from the video.
  ‚û°Ô∏è [View Agent Definitions (JSON)](./.roomodes)
  
* **üß© SPARC Development Workflow.pdf:** A detailed guide outlining the step-by-step SPARC process leveraging these Roomodes and research capabilities, from conception to deployment and maintenance.
  ‚û°Ô∏è [Read the Workflow Guide](./SPARC%20Development%20Workflow.pdf)
  
* **üìö Enhanced Context Documents** (From Video Demo - Contained within this Repo):
  * **SPARC Report:** Deep research findings on using SPARC effectively with AI. (Example of Deep Research output) ‚û°Ô∏è [View Report](./SPARC%20Report.pdf)
  * **SPARC Development Workflow:** A specific process document generated using AI. (Example artifact) ‚û°Ô∏è [View Workflow](./SPARC%20Development%20Workflow.pdf)
  * **"Uber Prompt SPARC":** A comprehensive starting prompt for AI program generation. (Example artifact) ‚û°Ô∏è [View Prompt](./Uber%20Prompt%20SPARC.pdf)
  
  These demonstrate the power of using AI to generate documentation and context for subsequent AI tasks, as discussed in the video.
  
* **üí° Video Context (Implicit):** The transcript/summary/link related to the original video explaining the genesis of these tools and demonstrating their use.

---

## üöÄ Get Started: Build Your Idea!

Ready to bring your vision to life using AI? Follow these steps:

### Prerequisites

1. **Visual Studio Code:** The code editor. Install it from [code.visualstudio.com](https://code.visualstudio.com).
2. **Roo Code Extension:** Install this directly from the VS Code Marketplace. Search for "Roo Code".
3. **AI Model API Key:** You'll need an API key from a supported provider (e.g., Anthropic for Claude models, OpenAI for GPT models). Configure this within the Roo Code extension settings.
4. **(Optional but Recommended for Full Power) MCP Tooling Keys:** To enable the `üîç Deep Research` (Perplexity AI), `üî• Fire Crawler`, and `üîê Supabase Admin` agents, you will likely need API keys for these services. The easiest way to manage these is often via cline (if available/applicable) or manual configuration in Roo Code's MCP settings. Check Roo Code documentation for details.

### Configuration

1. **Install SPARC Roomodes:**
   * Open a project in VSCode.
   * Open a Terminal (Make sure the terminal is opened up to the project directory)
   * In the terminal Type [npx create-sparc init](https://www.linkedin.com/pulse/automated-code-development-new-sparc-npx-create-sparc-reuven-cohen-8ujwe/)
   * Copy my roomodes over the roomodes that gets created in the project directory if you want to use perplexity research and fire crawl.
   * Save and close the file.

2. **Configure AI Model:**
   * In Roo Code settings, select the AI model you have an API key for (e.g., Claude 3.5 Sonnet via Anthropic). Ensure the corresponding API key is entered.

3. **(Optional) Configure MCP Connections:**
   * Follow Roo Code's documentation to configure Management Control Panel (MCP) connections for Perplexity AI, Firecrawl, and Supabase if you intend to use those agents heavily. This usually involves providing API keys and potentially server endpoints via cline or the settings UI.

### Let's Build!

1. **Download & Complete the Blueprint:**
   * Download the `Uber Prompt SPARC.pdf`.
   * Fill it out thoroughly and thoughtfully in plain English. Provide details, examples, and clear success criteria. The quality of your Blueprint directly impacts the quality of the AI's output.

2. **Start Roo Code Chat:**
   * Open VS Code.
   * Open a new Roo Code chat panel (usually via an icon in the activity bar or a command).

3. **Select Profile & Mode:**
   * Ensure your configured AI Model profile is active.
   * From the "Mode" dropdown in the Roo Code chat, select the `‚ö°Ô∏è SPARC Orchestrator` mode.

4. **Provide Your Blueprint:**
   * In the chat input, paste the complete text content of your filled-out Blueprint.
   * Precede it with a clear instruction, like:
   
   ```

5. **Observe & Guide (Minimally):**
   * The SPARC Orchestrator will now begin analyzing, researching, and delegating tasks to the other AI agents. It will use the `SPARC Development Workflow.pdf` as its guide.
   * Watch the process unfold in the chat. The goal is for the AI to proceed autonomously based on the Blueprint. It might ask clarifying questions if the Blueprint is ambiguous, but aim for completeness in your initial input.
   * If you need guidance during the process, you can switch to the `‚ùì Ask` mode for help on formulating requests or understanding SPARC.

6. **Receive Your Application:** The AI team will work through the SPARC phases, eventually aiming to present you with a functional application that meets the Success Criteria defined in your Blueprint!

---

## üôè Acknowledgements & Gratitude

This entire framework and workflow is built upon the pioneering work of [**Reuven Cohen**](https://www.linkedin.com/pulse/automated-code-development-new-sparc-npx-create-sparc-reuven-cohen-8ujwe/).

* The **SPARC** (Specification, Pseudocode, Architecture, Refinement, Completion) methodology is his conceptual framework for structured AI software development.
* The foundational definitions and roles of the specialized AI agents (Roomodes) originate from his designs and implementations.

This repository aims to make Reuven's powerful SPARC vision more accessible and practical by providing:

* A clear Zero-Code entry point (the Blueprint) for non-technical users.
* Integrated Deep Research and Web Crawling capabilities within the SPARC flow.
* Pre-packaged documentation and examples (like the SPARC Report/Workflow/Prompt) demonstrated in the video to enhance AI context.
* A consolidated and documented set of Roomodes for easy setup in Roo Code.

**Thank you, Reuven Cohen, for laying the groundwork for this exciting future of AI-driven development!**

Follow Reuven Cohen for more insights: üîó [Reuven Cohen on LinkedIn](https://www.linkedin.com/in/reuvencohen/)

---

## üìú License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## üîó Related & Helpful Resources

* [Roo Code Information (Official Docs/Blog)](https://roo.ai)
* [Reuven Cohen's SPARC Articles/Posts]([https://www.linkedin.com/in/reuvencohen/](https://www.linkedin.com/pulse/automated-code-development-new-sparc-npx-create-sparc-reuven-cohen-8ujwe/)) 
* [Perplexity AI](https://www.perplexity.ai/)
* [Firecrawl](https://firecrawl.dev/)
* [Supabase](https://supabase.com/)

---

## üë§ Connect With Me

üîó [LinkedIn - Christopher Royse](https://www.linkedin.com/in/christopher-royse-b624b596/)

---

**Let's build amazing things together! Provide your Blueprint and let the AI work its magic. ‚ú®**


# Welcome to the Ultimate AI Coding Swarm: A User's Guide

Hello! üëã Welcome to a revolutionary way to build software using a team of specialized AI assistants. Think of this system like a highly organized construction crew where each AI has a very specific job, and "Orchestrators" act as the project managers. This guide will walk you through everything you need to know to bring your software ideas to life, even if you're new to coding concepts!

**What is This System?**

This system uses a collection of AI "modes" (think of them as virtual robots or specialized assistants) defined in a configuration file called `roomodes.json`. Each mode has a specific role, like writing specifications, designing architecture, writing code, testing, or even researching. "Orchestrator" modes are special project managers that coordinate these specialists to build your application step-by-step.

The key ideas behind this system are:

1.  **Break Down Big Problems:** Complex software is built by breaking it into tiny, manageable pieces.
2.  **Tests First (Often!):** For new features, we often design all the quality checks (tests) *before* writing the main code. This tells the AI Coder exactly what "correct" looks like.
3.  **AI Specialization:** Each AI assistant is an expert in one small area.
4.  **Clear Communication:** You provide your vision, and the orchestrators manage the detailed communication between AI assistants.

**Our Goal:** To empower you to create complex and amazing software by guiding this team of AI assistants, without needing to write the code yourself.

## Table of Contents

1.  [Getting Started: The Pheromone File (A Tiny Bit of Setup)](#1-getting-started-the-pheromone-file-a-tiny-bit-of-setup)
2.  [Meet Your Project Managers: The Orchestrators](#2-meet-your-project-managers-the-orchestrators)
    *   [üåü Orchestrator (Project Initialization & Vision)](#-orchestrator-project-initialization--vision)
        *   [When to Use It](#when-to-use-it)
        *   [How It Works (Simplified)](#how-it-works-simplified)
        *   [Your Input: The User Blueprint](#your-input-the-user-blueprint)
    *   [ÎºàÎåÄ Orchestrator (Framework Scaffolding)](#-orchestrator-framework-scaffolding)
        *   [When to Use It](#when-to-use-it-1)
        *   [How It Works (Simplified)](#how-it-works-simplified-1)
    *   [üéØ Orchestrator (Test Specification & Generation)](#-orchestrator-test-specification--generation)
        *   [When to Use It](#when-to-use-it-2)
        *   [How It Works (Simplified)](#how-it-works-simplified-2)
    *   [‚öôÔ∏è Orchestrator (Feature Implementation - Test-Driven)](#Ô∏è-orchestrator-feature-implementation---test-driven)
        *   [When to Use It](#when-to-use-it-3)
        *   [How It Works (Simplified)](#how-it-works-simplified-3)
    *   [üîó Orchestrator (Integration & System Testing)](#-orchestrator-integration--system-testing)
        *   [When to Use It](#when-to-use-it-4)
        *   [How It Works (Simplified)](#how-it-works-simplified-4)
    *   [üîÑ Orchestrator (Refinement & Maintenance - Existing Code)](#-orchestrator-refinement--maintenance---existing-code)
        *   [When to Use It](#when-to-use-it-5)
        *   [How It Works (Simplified)](#how-it-works-simplified-5)
3.  [The Software Development Lifecycle with Your AI Swarm](#3-the-software-development-lifecycle-with-your-ai-swarm)
    *   [Step 1: The Idea & The Blueprint (You + Project Initialization Orchestrator)](#step-1-the-idea--the-blueprint-you--project-initialization-orchestrator)
    *   [Step 2: Building the Foundation (Framework Scaffolding Orchestrator)](#step-2-building-the-foundation-framework-scaffolding-orchestrator)
    *   [Step 3: Designing the Quality Checks for Each Feature (Test Specification & Generation Orchestrator)](#step-3-designing-the-quality-checks-for-each-feature-test-specification--generation-orchestrator)
    *   [Step 4: AI Writes Code to Pass the Checks (Feature Implementation Orchestrator)](#step-4-ai-writes-code-to-pass-the-checks-feature-implementation-orchestrator)
    *   [Step 5: Putting It All Together (Integration & System Testing Orchestrator)](#step-5-putting-it-all-together-integration--system-testing-orchestrator)
    *   [Step 6: Keeping it Great (Refinement & Maintenance Orchestrator)](#step-6-keeping-it-great-refinement--maintenance-orchestrator)
4.  [Best Practices for Working with Your AI Swarm](#4-best-practices-for-working-with-your-ai-swarm)
5.  [A Note on the "Specialist" AI Modes](#5-a-note-on-the-specialist-ai-modes)
6.  [Troubleshooting Common Scenarios & Which Orchestrator Helps](#6-troubleshooting-common-scenarios--which-orchestrator-helps)

---

## 1. Getting Started: The Pheromone File (A Tiny Bit of Setup)

Imagine ants leaving little trails (pheromones) to guide other ants to food or to warn them of danger. Our AI system uses a similar idea with a special file to help the orchestrators prioritize tasks or notice problem areas.

**What is the Pheromone File?**

*   It's a simple text file, usually named `board.json`, located in a folder like `.pheromones/` in your project directory.
*   It stores "signals" with "weights" (like how strong the ant trail is).
*   Example signals: `bug_detected_in_feature_X`, `coding_needed_for_feature_Y`.
*   The orchestrators and specialist AI modes read and update this file. You usually don't need to edit it directly!

**How to Set It Up (Super Easy!):**

1.  **Create a Folder:** In the main folder where your project will live (or already lives), create a new folder.
    *   On Windows: Right-click -> New -> Folder. Name it `.pheromones` (the dot at the beginning might make it hidden, which is okay).
    *   On Mac/Linux: Open Terminal, navigate to your project folder, and type `mkdir .pheromones` and press Enter.
2.  **Create an Empty File:** Inside that `.pheromones` folder, create an empty text file.
    *   On Windows: Right-click inside the `.pheromones` folder -> New -> Text Document. Name it `board.json`. Make sure the extension is `.json`, not `.json.txt`. (You might need to enable "File name extensions" in File Explorer's View menu).
    *   On Mac/Linux: In Terminal, navigate into `.pheromones` folder (`cd .pheromones`) and type `touch board.json` and press Enter.
3.  **Initial Content (Optional but good practice):** Open `board.json` with a simple text editor (like Notepad on Windows, TextEdit on Mac, or VS Code if you have it). You can leave it completely empty, or put this inside to start:

    ```json
    {}
    ```

    This just means "an empty collection of signals."

**That's it!** The system will automatically use and update this file.

**Why is this important (in simple terms)?**

If many AI Coder assistants report they are stuck on a particular feature, they might "deposit" a strong `bug_detected_in_feature_X` signal. When an orchestrator looks at its to-do list, it might see this strong signal and decide to prioritize getting a Debugger AI to look at that feature next. It helps the system adapt.

---

## 2. Meet Your Project Managers: The Orchestrators

Orchestrators are the "brains" of the operation. They take your high-level requests, break them down into smaller tasks, and assign those tasks to the right specialist AI modes. You will primarily interact with these orchestrators.

### üåü Orchestrator (Project Initialization & Vision)

*   **Slug:** `orchestrator-project-initialization`
*   **Purpose:** This is your **starting point for any brand new software idea.** It takes your dream and turns it into a concrete plan.

#### When to Use It:

*   You have a new app idea and want to build it from scratch.
*   You've filled out (or are ready to fill out) the "Zero-Code User Blueprint" (more on this below!).

#### How It Works (Simplified):

1.  You provide your "User Blueprint" (your detailed idea written in plain English).
2.  It sends this Blueprint to a "Research Planner" AI that explores similar apps, best technologies, and potential challenges.
3.  Based on the research and your Blueprint, it defines the major features of your app and a high-level design.
4.  It creates a "Master Project Plan" document that outlines everything, ready for the next orchestrator.

#### Your Input: The User Blueprint

This is the **most important document you will create** for a new project. It's a template you fill out, describing your idea without any technical jargon. The `Orchestrator (Project Initialization & Vision)` expects this.

**(You would include a simplified version of the Zero-Code User Blueprint template here, like the one you provided in the prompt, explaining each section briefly and how it helps the AI)**

**Key takeaway:** For a *new project*, start with this orchestrator and a well-thought-out User Blueprint.

---

### ÎºàÎåÄ Orchestrator (Framework Scaffolding)

*   **Slug:** `orchestrator-framework-scaffolding`
*   **Purpose:** After the initial plan is ready, this orchestrator sets up the **empty "skeleton" of your project.** Think of it as laying the foundation and putting up the basic frame of a house before building the rooms.

#### When to Use It (Usually Automated):

*   Right after the `Orchestrator (Project Initialization & Vision)` finishes.
*   You usually don't call this one directly; the system flows into it.

#### How It Works (Simplified):

1.  It takes the "Master Project Plan" (which includes technology choices like Python/React or Java/Spring).
2.  It tasks "DevOps" AI assistants to create the necessary folders, install basic tools (like linters to keep code tidy), and set up a very basic automated workflow (CI/CD) that can build and test your project later.
3.  It tasks "Coder" AI assistants to write the absolute bare minimum "boilerplate" code ‚Äì for example, an empty API structure or a file to connect to a database (but no actual features yet).
4.  It tasks a "Tester" AI to set up the testing system.

**Key takeaway:** This orchestrator builds the empty, runnable shell of your application.

---

### üéØ Orchestrator (Test Specification & Generation)

*   **Slug:** `orchestrator-test-specification-and-generation`
*   **Purpose:** This is a **crucial and unique orchestrator!** For *each feature* of your app, its job is to **design and then have AI assistants write all the quality checks (tests) BEFORE the feature's main code is written.**

#### When to Use It (Usually Automated):

*   After the project framework is scaffolded, this orchestrator will be called for each major feature defined in the Master Project Plan.
*   It can also be used by the `Orchestrator (Refinement & Maintenance)` when you request a new enhancement to an existing project.

#### How It Works (Simplified):

1.  It takes the high-level specification and architecture design for **one specific feature** (e.g., "User Login" feature).
2.  It tasks a specialist AI (`Spec_To_TestPlan_Converter`) to create a very detailed "Test Plan." This plan lists all the things that need to be checked for the feature to work correctly:
    *   "If user enters correct password, they should log in."
    *   "If user enters wrong password 3 times, account should be temporarily locked."
    *   "If username field is empty, show error message."
3.  Then, for each item in the Test Plan, it tasks another specialist AI (`Tester_TDD_Master`) to write the actual test *code*. This test code will try to use functions that *don't exist yet* (like a `loginUser()` function). So, these tests will initially fail, which is exactly what we want!

**Key takeaway:** This orchestrator ensures that for every feature, we know exactly what "correct" looks like (defined by the tests) *before* we try to build it. The failing tests become the precise instructions for the AI Coder.

---

### ‚öôÔ∏è Orchestrator (Feature Implementation - Test-Driven)

*   **Slug:** `orchestrator-feature-implementation-tdd`
*   **Purpose:** Its mission is simple: take a feature for which all tests have ALREADY been written (by the previous orchestrator) and manage AI Coder assistants to **write the source code that makes all those tests pass.**

#### When to Use It (Usually Automated):

*   After the `Orchestrator (Test Specification & Generation)` has finished creating all the tests for a specific feature.

#### How It Works (Simplified) - The "TDD Boomerang Cycle":

1.  It looks at the list of (currently failing) tests for the feature.
2.  It picks a small group of related failing tests (e.g., tests for the `loginUser()` function).
3.  It tasks an AI Coder (`Coder_Test_Driven`): "Here are tests A, B, and C. They are failing. Please write the `loginUser()` function in `auth_service.py` so that these tests pass. Here's the spec for what `loginUser()` should do."
4.  The Coder AI writes or modifies the `loginUser()` function and sends it back.
5.  The orchestrator (or a Tester AI it calls) runs *all* the tests for the feature again.
    *   **If all tests for the feature now pass:** Great! This feature is done.
    *   **If some tests still fail (or new ones start failing):**
        *   If the Coder seems stuck or the error is tricky, it might ask a "Debugger" AI (`Debugger_Targeted`) to look at the Coder's code and the failing tests to find the problem.
        *   It then goes back to step 2 or 3, giving the Coder (or Debugger's corrected code) the new information about which tests are still failing.
6.  This loop continues until every single pre-written test for that feature passes.

**Key takeaway:** This is where your actual feature code gets built. The AI Coders are relentlessly trying to satisfy the quality checks you designed earlier. It's okay if they take many tries ‚Äì that's how AI learns and gets it right based on the tests!

---

### üîó Orchestrator (Integration & System Testing)

*   **Slug:** `orchestrator-integration-and-system-testing`
*   **Purpose:** Once you have several features that have individually passed all their tests, this orchestrator **connects them all together** into the main application and runs tests to make sure they work correctly *with each other*.

#### When to Use It (Usually Automated):

*   After one or more features have been completed by the `Orchestrator (Feature Implementation - Test-Driven)`.
*   Often run before preparing a new version of your app for users.

#### How It Works (Simplified):

1.  It takes the code for the completed features.
2.  It tasks an "Integrator" AI (`Integrator_Module`) to merge these features into the main project code.
3.  If there are conflicts (e.g., two features changed the same file), it might use a Debugger AI to help resolve them.
4.  Once merged, it tasks a Tester AI (`Tester_TDD_Master`) to run "System-Wide Tests." These are broader tests that check complete user journeys or interactions between multiple features.
5.  If system tests fail, it will coordinate with Debugger AIs to find and fix these "integration bugs."

**Key takeaway:** This orchestrator ensures that the individual pieces of your app play nicely together.

---

### üîÑ Orchestrator (Refinement & Maintenance - Existing Code)

*   **Slug:** `orchestrator-refinement-and-maintenance`
*   **Purpose:** Use this orchestrator when you want to **make changes to a project that already exists** ‚Äì fixing bugs, adding small enhancements, or optimizing performance.

#### When to Use It:

*   You have an existing codebase (built by this system or even by humans!).
*   You want to:
    *   Fix a reported bug.
    *   Add a new, relatively contained feature or modification to an existing one.
    *   Improve the performance of a specific part of the application.

#### How It Works (Simplified):

1.  You provide a clear request (e.g., "The login page crashes if I enter a very long password," or "Add an option to export the user list as a CSV file").
2.  It first tasks a "Code Comprehension" AI (`CodeComprehension_Assistant_V2`) to understand the relevant parts of the *existing* code related to your request. This is super important because we don't want to break what's already working!
3.  **Test-First (even for changes!):**
    *   **For Bug Fixes:** It tasks a Tester AI to write a *new test that fails because of the bug*. This test proves the bug exists and defines when it's fixed.
    *   **For Enhancements:** It tasks specification and test generation AIs (similar to how new features are handled) to create a plan and write new tests for the *new behavior* you want.
4.  It then uses the `Orchestrator (Feature Implementation - Test-Driven)` logic (or a similar internal loop) to manage AI Coders. Their job is to modify the existing code to:
    *   Make the new bug-fixing test (or new enhancement tests) pass.
    *   **AND critically, ensure ALL OTHER EXISTING TESTS in the entire project STILL PASS!** This prevents regressions (breaking old stuff).
5.  It may also coordinate security reviews or documentation updates for the changed parts.

**Key takeaway:** This orchestrator is your go-to for evolving an existing application safely. It emphasizes understanding the current code first and then making changes in a test-driven way to avoid breaking things.

---

## 3. The Software Development Lifecycle with Your AI Swarm

Here's how these orchestrators typically work together to build a new application from your idea:

### Step 1: The Idea & The Blueprint (You + Project Initialization Orchestrator)

*   **You:** Have a brilliant idea! You carefully fill out the "Zero-Code User Blueprint," describing everything in plain English.
*   **Action:** You submit this Blueprint to the `Orchestrator (Project Initialization & Vision)`.
*   **Outcome:** The orchestrator and its research team will study your idea, investigate technologies, define major features, and create a `Master_Project_Plan.md`.

### Step 2: Building the Foundation (Framework Scaffolding Orchestrator)

*   **Action:** The `Orchestrator (Project Initialization & Vision)` automatically hands off the Master Plan to the `Orchestrator (Framework Scaffolding)`.
*   **Outcome:** This orchestrator sets up your project's empty folders, basic build tools, CI/CD, configuration files, and maybe some empty "boilerplate" code for your API or database. Your project is now a runnable (but empty) shell.

### Step 3: Designing the Quality Checks for Each Feature (Test Specification & Generation Orchestrator)

*   **Action:** For *each major feature* outlined in the Master Project Plan (e.g., "User Registration," then "Product Search," then "Shopping Cart"):
    1.  The `Orchestrator (Test Specification & Generation)` takes the feature's high-level spec and architecture.
    2.  It creates a detailed Test Plan for that feature.
    3.  It then instructs `Tester_TDD_Master` AIs to write all the actual test *code* for that feature. These tests will fail because the feature code doesn't exist.
*   **Outcome:** For each feature, you now have a complete set of "quality check" instructions (the test code).

### Step 4: AI Writes Code to Pass the Checks (Feature Implementation Orchestrator)

*   **Action:** For *each feature* that now has its tests written:
    1.  The `Orchestrator (Feature Implementation - Test-Driven)` takes the failing tests and the feature's spec/arch.
    2.  It repeatedly tasks `Coder_Test_Driven` AIs to write the actual source code for the feature.
    3.  After each Coder attempt, the orchestrator re-runs the feature's tests.
    4.  If tests fail, a `Debugger_Targeted` AI might be called in to help.
    5.  This loop continues until ALL tests for that specific feature pass.
*   **Outcome:** You get fully coded and *individually tested* features.

### Step 5: Putting It All Together (Integration & System Testing Orchestrator)

*   **Action:** Once several features are complete and have passed their own tests:
    1.  The `Orchestrator (Integration & System Testing)` takes these completed features.
    2.  It merges their code into the main application.
    3.  It then runs a big set of "System-Wide Tests" to ensure the features work correctly *together* and that the whole application behaves as expected.
*   **Outcome:** A more complete version of your application, with multiple features working in harmony.

### Step 6: Keeping it Great (Refinement & Maintenance Orchestrator)

*   **Action:** Months later, you want to add a small new option to the "Product Search" feature, or a user reports a bug in the "Shopping Cart."
    1.  You submit a clear request to the `Orchestrator (Refinement & Maintenance - Existing Code)`.
    2.  It analyzes the existing code related to your request.
    3.  It ensures new tests are written for your change/fix *first*.
    4.  It then tasks AI Coders to make those new tests pass *and* ensure all old tests still pass.
*   **Outcome:** Your application is updated or fixed safely, without breaking existing functionality.

This cycle (especially steps 3-5) can repeat for many features. For very large projects, features themselves might be broken down by `Orchestrator_Project_Initialization` into sub-features that follow a similar flow.

---

## 4. Best Practices for Working with Your AI Swarm

To get the best results from this powerful system:

1.  **Be Crystal Clear in Your User Blueprint (for New Projects):** This is your primary communication tool. The more detail, specific examples (especially for "Success Criteria"), and clarity you provide, the better the AIs can understand your vision. Garbage in, garbage out applies!
2.  **Write Clear Change Requests & Bug Reports (for Existing Projects):**
    *   **Bugs:** What did you do? What did you expect? What actually happened? Any error messages?
    *   **Enhancements:** What is the new behavior you want? Why is it needed? Who benefits?
3.  **Think in Features:** Break down your big idea into logical, user-facing features. The "Core Actions" and "Key Feature Deep Dive" in the Blueprint help with this.
4.  **Review AI Outputs at Key Stages:**
    *   After `Orchestrator_Project_Initialization`: Review the `Master_Project_Plan.md`. Does the feature list and high-level architecture make sense for your Blueprint?
    *   After `Orchestrator_Test_Specification_And_Generation`: Skim the `Test_Plan.md` for a key feature. Do the test scenarios seem to cover your "Success Criteria" from the Blueprint? (You don't need to read the test *code*).
    *   After `Orchestrator_Integration_And_System_Testing`: Try out the application if it's a runnable version. Does it behave as you expected for the integrated features?
5.  **Embrace Iteration, Especially with AI Coders:** The `Orchestrator (Feature Implementation - Test-Driven)` is *designed* for AI Coders to make multiple attempts. It's not a failure if the AI doesn't get it perfect on the first try. The tests are there to guide it. Trust the process.
6.  **Understand Context is Limited for AIs:** Each AI specialist only knows about the tiny task it's given. It doesn't remember previous conversations or other parts of the project unless the Orchestrator specifically tells it. This is why your initial Blueprint and clear change requests are so vital ‚Äì they are the source of truth.
7.  **Don't Specify *How* in Your Blueprint (Usually):** Focus on *what* you want the app to do and *why*. Let the `ResearchPlanner_Strategic` and `Architect_HighLevel_Module` AIs propose the best *how* (technologies, design patterns) based on your requirements. (The "Technical Preferences" section of the Blueprint is for when you have a *very strong, existing reason* to use a specific technology).
8.  **Patience for Complex Tasks:** Building complex software, even with AI, takes time. The orchestrators break things down, which means many small steps.
9.  **Use the Tutorial Mode:** When you're unsure, or just to see an example flow, the `Tutorial (Phased, Test-First AI Workflow)` mode can walk you through a simulated project.
10. **Ask for Clarification:** The `Ask (Ultimate Guide to Phased Orchestration & Test-First AI)` mode is there to help you understand any part of this process.

---

## 5. A Note on the "Specialist" AI Modes

While you primarily interact with the Orchestrators, they are coordinating a whole team of specialist AIs in the background. You don't usually talk to these specialists directly, but it's good to know they exist:

*   `ResearchPlanner_Strategic`: The super-researcher.
*   `SpecWriter_Feature_Overview`: Writes high-level feature descriptions.
*   `Architect_HighLevel_Module`: Designs parts of the app.
*   `DevOps_Foundations_Setup`: Sets up technical project parts.
*   `Coder_Framework_Boilerplate`: Writes basic empty code structures.
*   `Spec_To_TestPlan_Converter`: Turns feature descriptions into detailed test plans.
*   `Tester_TDD_Master`: Writes test code OR runs existing tests.
*   `Coder_Test_Driven`: Writes the actual feature code to pass tests.
*   `Debugger_Targeted`: Helps find and fix code problems.
*   `Integrator_Module`: Merges code from different features.
*   `CodeComprehension_Assistant_V2`: Understands existing code for changes.
*   `SecurityReviewer_Module`: Checks for security weaknesses.
*   `DocsWriter_Feature`: Writes user and technical documents.
*   `DevOps_Pipeline_Manager`: Manages deploying your app to the internet.
*   `Optimizer_Module`: Improves code performance or structure.
*   And a few low-level utility AIs like `MCP_Tool_Specialist` (for using external AI search tools) and `FireCrawler_Assistant` (for reading websites for research).

Understanding that this team is working behind the scenes helps appreciate how your high-level requests are transformed into working software!

---

## 6. Troubleshooting Common Scenarios & Which Orchestrator Helps

*   **"I have a brand new app idea!"**
    *   **Start with:** `Orchestrator (Project Initialization & Vision)` and a filled-out User Blueprint.
*   **"The AI seems to be misunderstanding a core feature of my new app."**
    *   **Check:** Your User Blueprint's description for that feature. Is it crystal clear?
    *   **Action:** You might need to provide a revised Blueprint (or a clarification document) to `Orchestrator (Project Initialization & Vision)` to restart or refine the planning for *that specific feature area*. The system is designed to be iterative.
*   **"My new app is built, but Feature X doesn't quite work like I described in my Blueprint."**
    *   **This indicates a potential gap.** Was the "Success Criteria" in your Blueprint for Feature X very clear? Did the `Test_Plan.md` (created by `Spec_To_TestPlan_Converter`) accurately capture that success criteria?
    *   **Action:** This is a "bug" or "misinterpretation." Submit a detailed bug report/change request to `Orchestrator (Refinement & Maintenance - Existing Code)`. It will analyze Feature X, likely have *new tests* written that better capture your original intent, and then task AI Coders to fix the code for Feature X to pass these new (and all old) tests.
*   **"I want to add a small new option to my existing, working app."**
    *   **Start with:** `Orchestrator (Refinement & Maintenance - Existing Code)`. Provide a clear description of the new option, where it fits, and how it should behave.
*   **"A user found a bug in my live application!"**
    *   **Start with:** `Orchestrator (Refinement & Maintenance - Existing Code)`. Provide a detailed bug report (steps to reproduce, expected vs. actual).
*   **"The AI Coder seems to be stuck trying to pass a specific test for a new feature."**
    *   **Trust the Process (Initially):** The `Orchestrator (Feature Implementation - Test-Driven)` is designed to use the `Debugger_Targeted` AI to help the Coder. This is normal.
    *   **If it's *really* stuck (many, many cycles on one test):** This might mean the test itself is impossible to pass given the feature's specification or architecture, OR the spec is contradictory. This is rare if the earlier phases were done well. You might need to (conceptually) flag this to a human overseer, or provide a clarifying note about the spec to the maintenance orchestrator which could then refine the spec and regenerate related tests.
*   **"I want to see what the AI is planning for testing Feature Y."**
    *   **Look for:** The output of the `Orchestrator (Test Specification & Generation)` for Feature Y. It will include a path to a `feature_Y_test_plan.md` file. This human-readable plan details all the test scenarios.
*   **"The whole app feels slow after a few features were added."**
    *   **Action:** Submit an "optimization request" to `Orchestrator (Refinement & Maintenance - Existing Code)`. Be specific if you know which part is slow. It can task `Optimizer_Module` AIs to investigate and improve performance, while still ensuring all tests pass.

---

This guide provides a comprehensive overview. The key is to start with a clear vision (your Blueprint for new projects, or clear requests for existing ones) and then trust the specialized orchestrators and AI assistants to follow this robust, test-driven process. Happy building!
